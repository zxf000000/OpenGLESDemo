# OpenGL ES 应用开发实践指南 iOS卷(3)

## 第三章 纹理

openGL ES 提供了一个为几何图形中的每个顶点设置不同颜色的方法. 不过实际上即使是拥有多重颜色顶点的三角形也无法在渲染场景中提供逼真的感觉.   
纹理是计算机图形中最复杂的话题之一.

### 3.1 什么是纹理

纹理是一个用来保存图像的颜色元素值的 OpenGL ES 缓存.  
纹理可以使用任何图像, 包括树木/面孔/砖块/云彩等. 当把纹理应用到几何图形中后,会使渲染的场景显得更自然,会使三角形的复杂组合像是真是的物体而不是只有颜色的面.  

在纹理的缓存中保存的颜色值可能要耗费很多的内存. 所有的嵌入式系统都为纹理设定了内存的最大尺寸限制.   
当用一个图像初始化一个纹理缓存之后, 在这个图像中的每个像素编程了纹理中的一个纹素. 与像素类似, 纹素保存颜色数据. 像素和纹素之间的差别很微妙: 像素通常标识计算机屏幕上的一个实际的像素点,因此,像素通常被用来作为一个测量单位. 与此相反,纹素存在于一个虚拟的没有尺寸的数学坐标系中.  

 纹理坐标系有一个命名为 S 和 T 的2D 轴, 在一个纹理中无论有多少个纹素,纹理的尺寸永远是在 S 轴上从0.0 到1.0 , 在 T  轴上从 0.0 到1.0. 从一个 1像素高64像素宽的初始化来的纹理会沿着整个 T 轴有一纹素, 沿着 S 轴有64 纹素.  
 
 ![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/19-1-2/55119527.jpg)
 
 > 在一些 OpenGL 的实现中会支持1D 和 3D 纹理.  1D 纹理相当于沿着 T 轴只有 1纹素, 3D 纹理就像一个层饼,一个在拥有 R,S 和T轴的坐标系中沿着R 轴堆叠的多个2D 纹理的层饼.
 
 
#### 3.1.1.1 对齐纹理和几何图形
 
 我们需要告诉 OpenGL ES 如何使用一个纹理来给几何图形对象着色.  
 
 在渲染时, GPU 会转换纯数学 OpenGL ES 坐标系中的每个顶点的 XYZ 坐标为帧缓存中所对应的真实像素位置. 帧缓存中的像素位置叫做 **视口**(viewport) 坐标. 转换为视口坐标的结果是所有绘制的集合图形都被拉伸以适合屏幕大小, 也就是说高比宽大了,后面会讲到如何控制GPU 的这个转换.  
 
 在每个顶点的 X, Y ,Z 坐标被转换成视口坐标后, GPU 会设置转换生成的三角形内的每个像素的颜色. 转换几何形状数据为帧缓存中的颜色像素的渲染步骤叫做**点阵化**(resterizing), 每个颜色像素叫做**片元**(fragment)  , 当 OpenGL ES 没有使用纹理时, GPU 会根据包含该片元的对象的顶点的颜色来计算每个片元的颜色.当设置了使用纹理后, GPU 会根据在当前绑定的纹理缓存中的纹素来计算每个片元的颜色.
   
程序需要指定怎么对齐纹理和顶点,以便让 GPU 知道每个片元的颜色由哪些纹素决定. 这个对齐又叫做 **映射**(mapping). 是通过扩展为每个顶点保存的数据来实现的: 除了 XYZ 坐标, 每个顶点还给出了 U 和V 坐标值. 每个U 坐标会映射顶点在视口中的最终位置到纹理中沿着S 轴的一个位置. V 坐标映射到T 轴,

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/19-1-2/97715520.jpg)


#### 3.1.2 纹理的取样模式

每个顶点的U 和 V 坐标会附加到每个顶点在视口坐标中的最终位置