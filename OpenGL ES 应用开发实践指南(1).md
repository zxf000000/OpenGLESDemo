# OpenGL ES 应用开发实践指南

## 第一张 使用现代图形硬件

> ES 是嵌入式的意思  
> 本书主要关注带有 `GLKit` 的 OpenGL ES 2.0 版本


### 1.1 3D 渲染

> 用3D 数据生成一个2D 图像的过程就叫做渲染.计算机上显示的图片是由矩形的颜色点组成的,这些矩形颜色点叫做像素.  
> 一个像素点通常含有红,绿,蓝三个元素

渲染3D 数据为一个2D 图像通常发生在几个不同的步骤中,包括设置图像中的每个像素的红,绿,蓝强度的计算.

### 1.2 为图形处理器提供数据

> 程序会保存3D 场景数据到硬件随机存取存储器中,嵌入式系统中的中央处理单元有专门为其分配的RAM, 在图形处理的过程中,GPU也有专门为其分配的RAM  
> OpenGL ES 是一种软件技术,部分运行在CPU,部分运行在GPU 上,横跨在两个处理器之间,协调两个内存区域之间的数据交换.

下图代表了3D 渲染相关的硬件组件之间的数据交换.  
![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/72560832.jpg)

每个箭头代表一个渲染性能的瓶颈.  
OpenGL ES 通常会高效的协调数据交换,但是程序与OpenGL ES 的交互方式会明显的增加或减少所需的数据交换的数量和类型.  

* 从一个内存区域复制数据到另一个内存区域的速度是相对较慢的.
* 所有的内存访问都是相对较慢的.读写速度远远小于计算速度.GPU 的性能总是受限于内存访问的性能.

#### 1.2.1 缓存: 提供数据最好的方式

> OpenGL ES 为两个内存区域间的数据交换定义了**缓存**的概念.  

**缓存**是指图形处理器能够控制和管理的连续RAM.  
程序从CPU 的内存复制数据到OpenGL ES 的缓存. 在GPU 获取了一个缓存的所有权之后,运行在CPU 中的程序理想情况下将不再接触这个缓存. 通过独占的缓存,GPU 就能够给尽可能的以最有效的方式读写内存. 图形处理器把他处理 大量数据的能力异步同时的应用到缓存上, 这意味着在GPU 使用缓存中的数据工作的同时,运行在CPU 中的程序可以继续执行  

**为缓存提供数据有如下步骤:**

* 生成(generate) --- 请求OpenGL ES 为图形处理器控制的缓存生成一个唯一标识符.
* 绑定(bind) --- 告诉OpenGL ES 为接下来的运算使用一个缓存.
* 缓存数据(buffer data) --- 让 OpenGL ES 为当前绑定的缓存分配并初始化足够的连续内存(通常是CPU控制的内存复制数据到分配的内存)
* 启用(enable)或禁止(disable) --- 告诉 OpenGL ES 在接下来的渲染中是否使用缓存中的数据.
* 设置指针(set pointers) --- 告诉 OpenGL ES 在缓存中的数据的类型和所有需要访问的数据的内存偏移值
* 绘图(draw) --- 告诉OpenGL ES 使用当前绑定并启用的缓存中的数据渲染整个场景或者某个场景中的一部分.
* 删除(delete) --- 告诉OpenGL ES 删除之前生成的缓存并释放相关的资源.

**每一步骤对应下面的c函数:** 

* `glGenBuffers()` --- 请求OpenGL ES为图形处理器控制的缓存生成一个唯一标识符.
* `glBindBufffer()` --- 告诉 OpenGL ES 为接下来 的运算使用一个缓存. 
* `glBufferData()` 或者 `glBufferSubData()` --- 分配足够初始化的连续内存.
* `glEnableVertexAttribArray()` 或者 `glDisableVertexArray()` --- 在接下来的渲染中是否使用缓存中的数据
* `glVertexAttribPointer` --- 缓存中的数据类型和所有需要访问的数据的内存偏移值.
* `glDrawArrays()` 或者 `glDrawElements()` --- 使用当前绑定并启用的缓存中的数据渲染整个场景或者某个场景的一部分.
* `glDeleteBuffers()` --- 删除之前生成的缓存并释放相关的资源.


#### 1.2.2 帧缓存

> GPU 需要知道应该在内存中的哪个位置存储渲染出来的2D 图像像素数据.  
> 接收渲染结果的缓冲区叫做 帧缓存(frame buffer)

可以同时存在很多帧缓存,并且可以通过 OpenGL ES 让GPU 吧渲染结果存储到任意数量的帧缓存中. 但是,屏幕显示像素要收到保存在前帧缓存(front frame buffer) 的特定帧缓存中的像素颜色元素的控制.

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/74278330.jpg)


### 1.3 OpenGL ES 的上下文

> 用于配置 OpenGL ES的保存在特定平台的软件数据结构中的信息会被封装到一个 OpenGL ES 上下文(context) 中.


OpenGL ES 是一个状态机. 这意味着在一个程序中设置一个配置值之后,这个值会一直保持.直到程序修改了这个值.  

OpenGL ES 会按需在CPU 和GPU 之间复制数据,知道何时发生数据复制有助于程序优化.  

### 1.4 一个3D 场景的几何数据

> 在位GPU 提供数据时,很多数据都可以省略,比如灯光和颜色,在渲染场景时,必须有一种数据是用来指定要渲染的图形的几何数据. 几何数据是相对于3D 坐标系定义的.

#### 1.4.1 坐标系

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/15755192.jpg)

上图是OpenGL 的坐标系, 每个箭头代表一个轴,每两个轴的角度都是90.  
OpenGL 不支持绝大部分的 非笛卡尔坐标系  

#### 1.4.2 矢量

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/43136702.jpg)

> 从某种意义上讲, 矢量是另一种诠释顶点的数据的方式. 矢量是既有方向又有距离的一个值.

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/69898636.jpg)

#### 1.4.3 点.线.三角形

> OpenGL ES 使用顶点数据来定义点,线段和三角形, 一个顶点会定义坐标系中的位置,两个顶点一个线段,三个顶点一个三角形.  
> OpenGL ES 只渲染 点/ 线/ 三角形  

### 1.5 小结

![](http://zhouxiaofei-image.oss-cn-hangzhou.aliyuncs.com/18-12-26/38670419.jpg)
